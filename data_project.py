# -*- coding: utf-8 -*-
"""Data_project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15DUBfEs4reWtkl_vSDdeOgz8IgCOF9YG

# **Gerekli kütüphaneleri çağırdık ve dosyamızı okuduk.**
"""

import time
import pandas as pd
import numpy as np
import seaborn as sns
import math
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
import matplotlib.pyplot as plt
import plotly.offline as py
from scipy.stats import zscore
from itertools import combinations
import plotly.graph_objects as go
import plotly.figure_factory as ff
from google.colab import drive
drive.mount('/content/drive')
 
df = pd.read_csv('drive/My Drive/WA_Fn-UseC_-Telco-Customer-Churn.csv', low_memory=False)

"""# **Gerekli fonksiyonlarımızı tanımladık.**

"""

def absHighPass(df, absThresh):
    passed = set()
    for (r, c) in combinations(df.columns, 2):
        if abs(df.loc[r, c]) >= absThresh:
            passed.add(r)
            passed.add(c)
    passed = sorted(passed)
    return df.loc[passed, passed]


def hatali_deger_test(a):
    for column_name in a:
        print("{} sütunu için problemli değerler : ".format(column_name))
        hatali_degerler = []
        for deger in df[column_name]:
            try:
                float(deger)
            except:
                print(deger)
                hatali_degerler.append(deger)
        print(set(hatali_degerler))


def churn_kategorize_et(value):
    if value == "No":
        return 0
    elif value == "Yes":
        return 1

def gender_kategorize_et(value):
    if value == "Female":
        return 0
    else:
        return 1


def plot_distribution(var_select, bin_size):
    tmp1 = churn[var_select]
    tmp2 = no_churn[var_select]
    hist_data = [tmp1, tmp2]

    group_labels = ['Churn : yes', 'Churn : no']
    colors = ['gold', 'lightblue']

    fig = ff.create_distplot(hist_data, group_labels, colors=colors, show_hist=True, curve_type='kde', bin_size=bin_size)

    fig['layout'].update(title=var_select, autosize=False, height=500, width=800)

    py.iplot(fig, filename='Density plot')

"""# **Verimizin ilk ve son beş satırını yazdırarak genel görünümünü inceledik.**"""

pd.set_option('display.max_columns',None)

df

"""# **Sütunların veri tiplerini inceledik.**"""

print(df.dtypes)

"""# **Veri setimizde null olan değerler var mı diye baktık varsa yazdırmasını istedik(null veri göremedik).**"""

print(df.isna().sum())

"""# **Her sütundaki benzersiz değerlerin sayısını görüntüledik.**

"""

print(df.nunique())

"""# **Her sütundaki benzersiz değerleri görüntüledik.**"""

for sutun_adi in df.columns:
    print("{} sütunundaki benzersiz değerler : {}".format(sutun_adi, df[sutun_adi].unique()))

"""# **String sütunlarda hatalı değer göremedik. Nümerik sütunlarda hatalı değer olup olmadığını inceledik.**

"""

hatali_deger_test(["TotalCharges","tenure","MonthlyCharges"])

"""# **Yeni abone olan müşterilerin toplam ödediği ücret " "  olarak gözükmekte. Bu hatalı değerleri düzeltelim.**



"""

df['TotalCharges'] = df['TotalCharges'].replace(" ", 0).astype('float64')

"""# **Aylık ücret ve toplam ücret sütunlarını inceleyip uç/aykırı değer var mı bakalım.**"""

plt.show()

plt.boxplot(df["MonthlyCharges"])
plt.title("Aylik ucret boxplot")
plt.show()

plt.boxplot(df["TotalCharges"])
plt.title("Toplam odenen ucret boxplot")
plt.show()

"""**Z-score yöntemi ile uç değer arayalım.**

---



***Aylık Ücretler ile Z-score***
"""

z_scores = zscore(df["MonthlyCharges"])
for threshold in range(1, 5):
    print("Eşik değeri: {}".format(threshold))
    print("Aylikta aykırı değerlerin sayısı: {}".format(len((np.where(z_scores > threshold)[0]))))
    print('------')

"""***Toplam Ücretler ile Z-score***"""

z_scores = zscore(df["TotalCharges"])
for threshold in range(1, 5):
    print("Eşik değeri: {}".format(threshold))
    print("Toplamda aykırı değerlerin sayısı: {}".format(len((np.where(z_scores > threshold)[0]))))
    print('------')

"""**Tukey yöntemi ile uç değer arayalım**

---



***Aylık Ücret ile Tukey Yöntemi***
"""

print("Aylik Tukey")
q75, q25 = np.percentile(df["MonthlyCharges"], [75, 25])
caa = q75 - q25
esik_degerleri = pd.DataFrame()
for esik_degeri in np.arange(1, 5, 0.5):
    min_deger = q25 - (caa * esik_degeri)
    maks_deger = q75 + (caa * esik_degeri)
    aykiri_deger_sayisi = len((np.where((df["MonthlyCharges"] > maks_deger) |
                                        (df["MonthlyCharges"] < min_deger))[0]))
    esik_degerleri = esik_degerleri.append({'esik_degeri': esik_degeri, 'aykiri_deger_sayısı': aykiri_deger_sayisi},
                                           ignore_index=True)
print(esik_degerleri)

"""***Toplam Ücret ile Tukey Yöntemi***"""

print("Toplam Tukey")
q75, q25 = np.percentile(df["TotalCharges"], [75, 25])
caa = q75 - q25
esik_degerleri = pd.DataFrame()
for esik_degeri in np.arange(1, 5, 0.5):
    min_deger = q25 - (caa * esik_degeri)
    maks_deger = q75 + (caa * esik_degeri)
    aykiri_deger_sayisi = len((np.where((df["TotalCharges"] > maks_deger) |
                                        (df["TotalCharges"] < min_deger))[0]))
    esik_degerleri = esik_degerleri.append({'esik_degeri': esik_degeri, 'aykiri_deger_sayısı': aykiri_deger_sayisi},
                                           ignore_index=True)
print(esik_degerleri)

"""***Grafiklerimizden ve yöntemlerden elde ettiğimiz sonuçlara göre uç veri sorunu ile karşılaşmadık.***

# **Chrun, Gender, Partner, PhoneService sütunlarını kategorize edelim.**
"""

df['Churn-category'] = df['Churn'].apply(churn_kategorize_et)
df['Gender-category'] = df['gender'].apply(gender_kategorize_et)
df['Partner-category'] = df['Partner'].apply(churn_kategorize_et)
df['PhoneService-category'] = df['PhoneService'].apply(churn_kategorize_et)
print(df.dtypes)

"""# **Verimizde toplam ayrılma ayrılmama sayıları şu şekildedir.**"""

trace = go.Bar(
    x=(df['Churn'].value_counts().values.tolist()),
    y=['Churn : no', 'Churn : yes'],
    orientation='h', opacity=0.8,
    text=df['Churn'].value_counts().values.tolist(),
    textfont=dict(size=15),
    textposition='auto',
    marker=dict(
        color=['lightblue', 'gold'],
        line=dict(color='#000000', width=1.5)
    ))

layout = dict(title='Ayrilip ayrilmama sayilari',
              autosize=False,
              height=500,
              width=800)

fig = dict(data=[trace], layout=layout)
py.iplot(fig)

"""# **Veriler arasında bir ilişki olup olmadığını kontrol etmek için korelasyon matrisimizi oluşturuyoruz.**

"""

korelasyon_mat_df = df.corr()
print(korelasyon_mat_df)
sns.heatmap(absHighPass(korelasyon_mat_df,0.2), annot=True, cmap="YlGnBu")
plt.title("Korelasyon Matrisi")

"""**Korelasyon matirisnde görüyoruz ki MonthlyCharges, TotalCharges ve tenure değişkenlerinin serviste kalıp kalmamak ile ilgili bir bağlantısı olabilir.**

# **MonthlyCharges, TotalCharges ve tenure değişkenlerini inceleyelim.**

**MonthlyCharges değişkeni**


---



*   Veri normal dağılım değil Bi-Modal dağılım göstermiştir.
*   Kullanıcıların çoğu 18 ile 25 dolar arası ücret ödemektedir.
*   Giris seviyesi ana paket varmış gibi gözükmekte.
"""

sns.distplot(df["MonthlyCharges"])
plt.show()

"""**TotalCharges değişkeni**

---



*   Veri pozitif(sağa) çarpıktır.
*   Kullanıcılar ortalama 1100 dolar gibi toplam ücret odemişlerdir.






"""

sns.distplot(df["TotalCharges"])
plt.show()

"""**Tenure değişkeni**

---


* Veri normal dağılım değil Bi-Modal dağılım göstermiştir.
* Yoğunluk hizmete yeni katılanlar ve hizmette uzun süre duranlardadır.




"""

sns.distplot(df["tenure"])
plt.show()

"""**Churn(ayrılma) durumunun TotalCharges, MonthlyCharges ve tenure ile karşılaltırılması.**

---


"""

df.Churn.replace(to_replace=dict(Yes=1, No=0), inplace=True)

col_name = ['SeniorCitizen', 'Churn']
df[col_name] = df[col_name].astype(object)

churn = df[(df['Churn'] != 0)]
no_churn = df[(df['Churn'] == 0)]


plot_distribution('MonthlyCharges', False)
time.sleep(1)
plot_distribution('TotalCharges', False)
time.sleep(1)
plot_distribution('tenure', False)

"""**Görülüyor ki;**

*   Servisten ayrılan kullanıcılar genellikle ilk ay hizmeti satın alanlardır.
*   Servisten ayrılma oranı kullanma suresi geçtikçe artmaktadır.

*   Kullanıcı 10-20 ay arası serviste kaldıysa daha uzun süre durmaya eğilimlidir.
*   65 ay ve üzeri üye olanların çogu serviste halen kalmaktadır.
* 70 ve 110 dolar arası ücret ödeyen kullanıcılar servisten ayrılma oranı daha fazla gözükmekte.

# **Diğer değişkenlerin ayrılıp ayrılmama oranlarını inceleyelim.**
"""

def barplot(x):
  df1 = df.groupby(x)["Churn-category"].value_counts(normalize=True)
  df1 = df1.mul(100)
  df1 = df1.rename('percent').reset_index()

  g = sns.catplot(x=x,y='percent',hue="Churn-category",kind='bar',data=df1)
  g.ax.set_ylim(0,100)

  for p in g.ax.patches:
    txt = str(p.get_height().round(2)) + '%'
    txt_x = p.get_x() 
    txt_y = p.get_height()
    g.ax.text(txt_x,txt_y,txt)

barplot('SeniorCitizen')

"""**Senior Citizen olanlar ayrılmaya daha yatkındırlar.**"""

barplot('InternetService')

"""**İnternet servisi alıp Fiber optik altyapısını kullananlar ayrılmaya daha yatkındır.**"""

barplot('OnlineSecurity')

"""**Online güvenlik hizmeti kullanmayanlar ayrılmaya daha yatkındır**"""

barplot('OnlineBackup')

"""**Online yedekleme hizmeti kullanmayanlar ayrılmaya daha yatkındır.**"""

barplot('DeviceProtection')

"""**Cihaz koruma hizmeti kullanmayanlar ayrılmaya daha yatkındır.**"""

barplot('TechSupport')

"""**Teknik destek hizmeti almayanlar ayrılmaya daha yatkındır.**"""

barplot('Contract')

"""**Kullanıcı ne kadar uzun bir kontrat süresine sahipse serviste kalmaya o kadar yatkındır.**"""

barplot('PaymentMethod')

"""**Elektronik çek ile ödeme yapanlar servisten ayrılmaya daha yatkındır.**"""

df['TotalServices'] = (df[['PhoneService', 'InternetService', 'OnlineSecurity', 'OnlineBackup', 'DeviceProtection', 'TechSupport', 'StreamingTV', 'StreamingMovies']]== 'Yes').sum(axis=1)
barplot('TotalServices')

df = df.drop(columns = [
                            'MultipleLines',
                            'PhoneService', 
                            'Partner'
                           ])

"""**Grafiğe göre kullanıcı kaç adet servis kullanıyorsa ayrılma ihtimali buna orantılı olarak azalmaktadır.**

**Aşağıdaki değişkenlerde oranlardan dolayı ayrılıp ayrılmamaya pek bir etki gözlenmemektedir.**

---
"""

barplot('gender')
barplot('PhoneService')
barplot('MultipleLines')
barplot('Dependents')
barplot('Partner')
barplot('StreamingTV')
barplot('StreamingMovies')
barplot('PaperlessBilling')

"""# **PCA(Principal Component Analysis) yapalım.**"""

from sklearn.preprocessing import MinMaxScaler
from sklearn.decomposition import PCA
import plotly.express as px
Input =df[['TotalCharges','tenure','MonthlyCharges','SeniorCitizen','Churn-category']]
print(Input)
norm_X = MinMaxScaler().fit_transform(Input)
print(norm_X)
pca = PCA(n_components=3)
X_pca = pca.fit_transform(norm_X)
evr = np.cumsum(pca.explained_variance_ratio_)
print(evr)

plt.plot(range(1,len(evr)+1),evr)
plt.xticks(range(1,len(evr)+1))
plt.title("Explained variance ratio")
plt.ylabel("Explained variance ratio")
plt.xlabel("n_components")
plt.show()


X_pca=pd.DataFrame(X_pca)
X_pca.columns=["pc1","pc2","pc3"]
X_pca["y"]=df["Churn"]


fig = px.scatter_3d(X_pca, x='pc1', y='pc2', z='pc3',color='y',title="Churn 3D")
fig.update_traces(marker_coloraxis=None)
fig.show()

"""**Analizde 3 ve üzeri değişken kullandığımızda %90 açıklanan varyans oranına erişebiliyoruz.**"""